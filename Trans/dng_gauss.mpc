import numpy as np
from distributed_sampler.config import config
from mpmath import *
from math import exp, log2, log, ceil, sqrt
from scipy.stats import nbinom
from scipy import stats
# parameters 

class dgauss_generator(object):
    def __init__(self, conf) -> None:
        self.n, self.m, self.lambd = conf.n, conf.num_party, conf.lambd
        self.partial_noise, self.output_path = conf.partial_noise, conf.output_path
        self.sigma = conf.sensitivity * sqrt(2*ln(1.25/conf.delta)) / conf.epsilon

        # 目标是DGauss分布，和目标分布的统计距离只来自截断
        print('sigma', self.sigma)
        print(sqrt(2 * ln(2) * (self.lambd + 2 + log2(self.n))) * self.sigma - 1)
        self.k = max(int(ceil(log2(sqrt(2 * ln(2) * (self.lambd + 2 + log2(self.n))) * self.sigma - 1))), 1)
        self.sbg = sbitint.get_type(self.k)
        self.sbl = sbitint.get_type(self.k+1)
        self.N = 2 ** self.k + 1
        print(f'k derived from allocating lambda to truncation: {self.k}')
        print(f'mod clip N: {self.N}')

    def module_clip(self, noise):
        return (noise + self.N % (2 * self.N)) - self.N

    def output_pn_to_clients(self, noise):
        signs = noise > 0
        for i in range(self.m):
            with open(self.output_path + f'/client-input-P{i}-0', 'w') as f:
                for j in range(self.n):
                    f.write(str(int(signs[i][j])) + ' ')
                    f.write(str(abs(noise[i][j])) + ' ')
            f.close()

    def sample_from_gauss(self):
        partial_gaussian = np.round(np.random.normal(0, self.sigma, size=(self.m, self.n)) / sqrt(self.m)).astype(int)
        return self.module_clip(partial_gaussian)
    
    def generate_partial_noise(self):
        noise = self.sample_from_gauss()
        self.output_pn_to_clients(noise)

    def aggregate_discrete(self):
        dlaps = Array(self.n, self.sbl)
        @for_range(self.n)
        def _(i):
            dlaps[i] = self.sbl(0)
        
        for i in range(self.m):
            @for_range(self.n)
            def _(j):
                sign = sbit.get_input_from(i)
                partial_noise = self.sbl.get_input_from(i)
                partial_noise = sign.if_else(partial_noise, -partial_noise)
                dlaps[j] = dlaps[j] + partial_noise
        @for_range(self.n)
        def _(i):
            print_ln("dlap: %s", dlaps[i].reveal())
        return dlaps 
    
    def KS_test_discrete(self, D):
        sfix.set_precision(32)
        k, N = self.k, self.N
        n = self.n
        D_cit = 1.36 * sqrt(2/n)

        test_list = Array(n, sfix)
        f_table = Array(2*N+1, sfix)
        obs_table = Array(self.n, sfix)
        idx_table = Array(2*N+1, self.sbl)
        dlap_cdf = stats.norm.cdf(np.linspace(-N, N+1, 2*N+1), scale=10*self.sigma)

        for i in range(2*N+1):
            f_table[i] = sfix(dlap_cdf[i] * self.n)
            idx_table[i] = self.sbl(i-N)

        @for_range_opt(n)
        def _(i):
            f_dis = sfix(0)
            @for_range_opt(2*N+1)
            def _(j):
                equal = (D[i] == idx_table[j])
                f_dis.update(equal.if_else(f_table[j], f_dis))
            obs_table[i] = f_dis
        obs_table.sort()

        f_max = sfix(0)
        @for_range_opt(self.n)
        def _(i):
            f_dis = abs(i - obs_table[i])
            f_new = (f_max > f_dis).if_else(f_max, f_dis)
            f_max.update(f_new)
        print_ln("res: %s", f_max.reveal())
        return f_max < D_cit

import sys
config.lambd = int(sys.argv[4])
config.n = int(sys.argv[5])
config.epsilon = float(sys.argv[6])

generator = dgauss_generator(config)
generator.generate_partial_noise()
noise = generator.aggregate_discrete()
generator.KS_test_discrete(noise)
            

