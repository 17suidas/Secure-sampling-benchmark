import numpy as np
from distributed_sampler.config import config
from mpmath import *
from math import exp, log2, log, ceil, sqrt
from scipy.stats import nbinom
from scipy import stats
# parameters 

class dlap_generator(object):
    def __init__(self, conf) -> None:
        self.n, self.m, self.lambd = conf.n, conf.num_party, conf.lambd
        self.partial_noise, self.output_path = conf.partial_noise, conf.output_path
        self.t = conf.sensitivity / conf.epsilon
        p = exp(1 / self.t)

        # 目标是DLaplace分布，和目标分布的统计距离只来自截断
        self.k = int(ceil(log2(self.t * ((self.lambd + 1 + log2(self.n)) - log2(1 + p)) * log(2))))
        self.sbg = sbitint.get_type(self.k)
        self.sbl = sbitint.get_type(self.k+1)
        self.N = 2 ** self.k + 1
        print(f'k derived from allocating lambda to truncation: {self.k}')
        print(f'mod clip N: {self.N}')

    def module_clip(self, noise):
        return (noise + self.N % (2 * self.N)) - self.N

    def output_pn_to_clients(self, noise):
        signs = noise > 0
        for i in range(self.m):
            with open(self.output_path + f'/client-input-P{i}-0', 'w') as f:
                for j in range(self.n):
                    f.write(str(int(signs[i][j])) + ' ')
                    f.write(str(abs(noise[i][j])) + ' ')
            f.close()

    def sample_from_polya(self):
        r = exp(-1 / self.t)
        polya1 = nbinom.rvs(n=1/self.m, p=(1-r), size=(self.m, self.n))
        polya2 = nbinom.rvs(n=1/self.m, p=(1-r), size=(self.m, self.n))
        return self.module_clip(polya1 - polya2)
    
    def generate_partial_noise(self):
        if self.partial_noise == 'polya':
            noise = self.sample_from_polya()
            # print(noise)
            self.output_pn_to_clients(noise)

    def aggregate_discrete(self):
        dlaps = Array(self.n, self.sbl)
        @for_range(self.n)
        def _(i):
            dlaps[i] = self.sbl(0)
        
        for i in range(self.m):
            @for_range(self.n)
            def _(j):
                sign = sbit.get_input_from(i)
                partial_noise = self.sbl.get_input_from(i)
                partial_noise = sign.if_else(partial_noise, -partial_noise)
                dlaps[j] = dlaps[j] + partial_noise
        @for_range(self.n)
        def _(i):
            print_ln("dlap: %s", dlaps[i].reveal())
        return dlaps 
    
    def KS_test_discrete(self, D):
        print_ln("begin KS test")
        sfix.set_precision(32)
        k, N = self.k, self.N
        n = self.n
        D_cit = 1.36 * sqrt(2/n)

        test_list = Array(n, sfix)
        f_table = Array(2*N+1, sfix)
        obs_table = Array(self.n, sfix)
        idx_table = Array(2*N+1, self.sbl)
        dlap_cdf = stats.laplace.cdf(np.linspace(-N, N+1, 2*N+1), scale=self.t)

        for i in range(2*N+1):
            f_table[i] = sfix(dlap_cdf[i] * self.n)
            idx_table[i] = self.sbl(i-N)

        num_and = self.n * N
        print("num of AND gates", num_and)
        @for_range_opt(n)
        def _(i):
            f_dis = sfix(0)
            @for_range_opt(2*N+1)
            def _(j):
                equal = (D[i] == idx_table[j])
                f_dis.update(equal.if_else(f_table[j], f_dis))
            obs_table[i] = f_dis
        obs_table.sort()

        # @for_range(n)
        # def _(i):
        #     print_ln('Sorted %s', obs_table[i].reveal())
        f_max = sfix(0)
        order_list = Array(self.n, sfix)
        # @for_range(self.n)
        # def _(i):
        #     order_list[i] = sfix(i)
        @for_range_opt(self.n)
        def _(i):
            f_dis = abs(i - obs_table[i])
            f_new = (f_max > f_dis).if_else(f_max, f_dis)
            f_max.update(f_new)
        print_ln("res: %s", f_max.reveal())
        return f_max < D_cit

import sys
config.lambd = int(sys.argv[4])
config.n = int(sys.argv[5])
config.epsilon = float(sys.argv[6])


generator = dlap_generator(config)
generator.generate_partial_noise()
noise = generator.aggregate_discrete()
generator.KS_test_discrete(noise)
        